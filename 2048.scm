(import r7rs)
(import srfi-1)
(import srfi-197)
(load "../sicp/lib.scm")

(define gameboard '((0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0)))

(define (list-ref-random lst)
  (chain (* (random) (length lst))
      (floor _)
      (list-ref lst _)))

(define (indexes-of-zeros lst)
  (define (indexes-of-zeros-iter lst count acc)
    (if (null? lst)
	acc
	(indexes-of-zeros-iter (cdr lst)
			       (+ 1 count)
			       (if (zero? (car lst))
				   (append acc (list count))
				   acc))))
  (indexes-of-zeros-iter lst 0 '()))

(define (place-random-number gb)
  (let* ((i (list-ref-random (indexes-of-zeros (flatten gb))))
	 (r (floor (/ i 4)))
	 (c (modulo i 4))
	 (row (list-ref gb r)))
    (append (take gb r)
	    (list (append (take row c)
			  (list (if (< (random) 0.1) 4 2))
			  (take-right row (- (length row) c 1))))
	    (take-right gb (- (length gb) r 1)))))

(define (shift-left gameboard)
  (place-random-number
   (map (lambda (row) (let ((r (append (filter (lambda (x) (not (zero? x))) row)
				  (make-list (count zero? row) 0))))
		   (cond ((and (= (car r) (cadr r)) (= (caddr r) (cadddr r)))
			  (list (* 2 (car r)) (* 2 (caddr r)) 0 0))
			 ((= (car r) (cadr r))
			  (list (* 2 (car r)) (caddr r) (cadddr r) 0))
			 ((= (cadr r) (caddr r))
			  (list (car r) (* 2 (cadr r)) (cadddr r) 0))
			 ((= (caddr r) (cadddr r))
			  (list (car r) (cadr r) (* 2 (caddr r)) 0)))))
	gameboard)))

(define (shift-right gameboard)
  (place-random-number
   (map (lambda (row) (let ((r (append (make-list (count zero? row) 0)
				  (filter (lambda (x) (not (zero? x))) row))))
		   (cond ((and (= (car r) (cadr r)) (= (caddr r) (cadddr r)))
			  (list 0 0 (* 2 (car r)) (* 2 (caddr r))))
			 ((= (car r) (cadr r))
			  (list 0 (* 2 (car r)) (caddr r) (cadddr r)))
			 ((= (cadr r) (caddr r))
			  (list 0 (car r) (* 2 (cadr r)) (cadddr r)))
			 ((= (caddr r) (cadddr r))
			  (list 0 (car r) (cadr r) (* 2 (caddr r)))))))
	gameboard)))

(define (shift-up gameboard)
  (apply zip (shift-left (apply zip gameboard))))

(define (shift-down gameboard)
  (apply zip (shift-right (apply zip gameboard))))

(define (loop gameboard)
  (newline)
  (newline)
  (for-each (lambda (row) (display row) (newline)) gameboard)
  (display "Enter move:")
  (newline)
  (let ((input (read)))
    (cond ((symbol=? input 'up)    (loop (shift-up gameboard)))
	  ((symbol=? input 'down)  (loop (shift-down gameboard)))
	  ((symbol=? input 'left)  (loop (shift-left gameboard)))
	  ((symbol=? input 'right) (loop (shift-right gameboard)))
	  (else (begin (display "Invalid input.") (loop gameboard))))))

(loop (place-random-number (place-random-number gameboard)))

